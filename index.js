// Generated by CoffeeScript 2.0.0-beta2
var _, dateformat, format, numeral, parse;

dateformat = require('dateformat-nodep');

numeral = require('numeral');

_ = require('lodash');

format = function(inputObj, options) {
  var betweenStr, borderline, bottomline, collen, columnHeaders, columnLengthArray, diff, extra, formatstr, i, j, k, key, keys, l, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, lineAr, linestr, longDashes, longStringOfSpaces, m, n, newStrAr, numberformat, o, obj, p, partsMax, q, r, ref, ref1, ref2, ref3, rlen, s, sp, spacePad, spacePadLen, startLine, str, t, tempAr, topline, u, v, val, w, x, y, z;
  options = options || {};
  betweenStr = "│";
  startLine = "│";
  lineAr = [];
  if (inputObj && inputObj.length) {
    obj = inputObj[0];
    keys = _.keys(obj);
    len = keys.length;
    partsMax = 1;
    columnLengthArray = {};
    if (options.longdateformat) {
      formatstr = 'mm/dd/yyyy  hh:MM tt';
    } else {
      formatstr = 'mmm dd  hh:MM tt';
    }
    for (i = m = 0, len1 = keys.length; m < len1; i = ++m) {
      key = keys[i];
      columnLengthArray[key] = 3;
      sp = key.split(/[_\.]/);
      for (p = 0, len2 = sp.length; p < len2; p++) {
        str = sp[p];
        columnLengthArray[key] = Math.max(columnLengthArray[key], str.length);
      }
      partsMax = Math.max(partsMax, sp.length);
    }
    for (j = q = 0, len3 = inputObj.length; q < len3; j = ++q) {
      obj = inputObj[j];
      for (k = r = 0, len4 = keys.length; r < len4; k = ++r) {
        key = keys[k];
        val = obj[key];
        if (val) {
          if (_.isDate(val)) {
            val = dateformat(val, formatstr);
          } else if (_.isNumber(val)) {
            numberformat = options != null ? (ref = options.numberformat) != null ? ref[key] : void 0 : void 0;
            if (numberformat) {
              val = numeral(val).format(numberformat);
            }
          }
          columnLengthArray[key] = Math.max(val.toString().length, columnLengthArray[key]);
        }
      }
    }
    longStringOfSpaces = '                                                                                                                                                                                                                                                                                                ';
    longDashes = '────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────';
    linestr = startLine;
    newStrAr = [];
    for (i = s = 0, ref1 = partsMax; s < ref1; i = s += 1) {
      newStrAr.push(startLine);
    }
    borderline = startLine;
    for (l = t = 0, len5 = keys.length; t < len5; l = ++t) {
      key = keys[l];
      collen = columnLengthArray[key];
      borderline += longDashes.slice(0, collen + 2) + betweenStr;
      tempAr = [];
      for (i = u = 0, ref2 = partsMax; u < ref2; i = u += 1) {
        tempAr.push('');
      }
      sp = key.split(/[_\.]/);
      for (i = v = 0, len6 = sp.length; v < len6; i = ++v) {
        str = sp[i];
        tempAr[i] = str;
      }
      while (!tempAr[partsMax - 1]) {
        tempAr.pop();
        tempAr.unshift('');
      }
      for (i = w = 0, len7 = tempAr.length; w < len7; i = ++w) {
        str = tempAr[i];
        if (!str.length) {
          newStrAr[i] += ' ' + longStringOfSpaces.slice(0, collen) + ' ' + betweenStr;
          continue;
        }
        spacePad = '';
        extra = '';
        if (collen !== str.length) {
          diff = collen - str.length;
          spacePad = longStringOfSpaces.slice(0, diff / 2);
          extra = longStringOfSpaces.slice(0, diff % 2);
        }
        newStrAr[i] += ' ' + spacePad + str + extra + spacePad + ' ' + betweenStr;
      }
    }
    columnHeaders = newStrAr.join('\n');
    lineAr.push(columnHeaders);
    linestr = '├─';
    for (i = x = 0, len8 = keys.length; x < len8; i = ++x) {
      key = keys[i];
      linestr += `${longDashes.slice(1, +columnLengthArray[key] + 1 || 9e9)}─${betweenStr}─`;
    }
    linestr = linestr.replace(/─│─/g, '─┼─');
    linestr = linestr.replace(/┼─$/g, '┤');
    lineAr.push(linestr);
    for (n = y = 0, len9 = inputObj.length; y < len9; n = ++y) {
      obj = inputObj[n];
      linestr = startLine + ' ';
      for (o = z = 0, len10 = keys.length; z < len10; o = ++z) {
        key = keys[o];
        val = obj[key];
        if (_.isArray(val)) {
          val = JSON.stringify(val);
        }
        if (_.isBoolean(val)) {
          val = val.toString();
        }
        if (_.isNumber(val)) {
          numberformat = options != null ? (ref3 = options.numberformat) != null ? ref3[key] : void 0 : void 0;
          if (numberformat) {
            val = numeral(val).format(numberformat);
          }
          val = _.trim(val.toString());
          len = val.length;
          spacePadLen = columnLengthArray[key] - len;
          spacePad = longStringOfSpaces.slice(1, +spacePadLen + 1 || 9e9);
          if (options.meetInMiddle) {
            if (spacePad.length > 60) {
              spacePad = spacePad.substring(0, 60);
            }
          }
          if (options.meetInMiddle && o % 2 === 1) {
            linestr += `${val}${spacePad} ${betweenStr} `;
          } else {
            linestr += `${spacePad}${val.toString()} ${betweenStr} `;
          }
        } else {
          if (toString.call(val) === '[object Date]') {
            val = dateformat(val, formatstr);
            val = val.replace(', 0', ',  ');
          }
          if (val == null) {
            val = '';
          }
          spacePadLen = columnLengthArray[key] + 1 - val.length;
          spacePad = longStringOfSpaces.slice(1, +spacePadLen + 1 || 9e9);
          if (options.meetInMiddle) {
            if (spacePad.length > 60) {
              spacePad = spacePad.substring(0, 60);
            }
          }
          if (options.meetInMiddle && o % 2 === 0) {
            spacePad = longStringOfSpaces.slice(2, +spacePadLen + 1 || 9e9);
            linestr += `${spacePad}${val}${betweenStr} `;
          } else {
            linestr += `${val}${spacePad}${betweenStr} `;
          }
        }
      }
      linestr += betweenStr;
      linestr = linestr.substr(0, linestr.length - 2);
      lineAr.push(linestr);
    }
    topline = borderline.replace(/─│─/g, '─┬─');
    topline = topline.replace(/│─/g, '┌─');
    topline = topline.replace(/─│/g, '─┐');
    bottomline = borderline.replace(/─│─/g, '─┴─');
    bottomline = bottomline.replace(/│─/g, '└─');
    bottomline = bottomline.replace(/─│/g, '─┘');
    lineAr.unshift(topline);
    lineAr.unshift('');
    lineAr.push(bottomline);
    rlen = inputObj.length;
    if (rlen === 1) {
      lineAr.push("  (1 row returned)");
    } else {
      lineAr.push(`  (${rlen} rows returned)`);
    }
    lineAr.push('');
  } else {
    lineAr.push("  (0 rows returned)");
  }
  return lineAr.join('\n');
};

parse = function(text) {
  var headerSeen, i, len1, len2, line, lineParts, lines, m, newObj, p, prop, propArray, retArray, val, valFound;
  retArray = [];
  headerSeen = false;
  propArray = [];
  lines = _.split(text, '\n');
  for (i = m = 0, len1 = lines.length; m < len1; i = ++m) {
    line = lines[i];
    line = _.trim(line);
    if (_.startsWith(line, '#')) {
      continue;
    }
    if (!line) {
      continue;
    }
    lineParts = _.split(line, '|');
    if (lineParts.length < 3) {
      continue;
    }
    if (_.startsWith(lineParts[1], '-')) {
      continue;
    }
    if (!headerSeen) {
      headerSeen = true;
      propArray = lineParts.slice(1).map(function(item) {
        return _.trim(item);
      }).filter(function(item) {
        return item !== '';
      });
      continue;
    }
    newObj = {};
    valFound = false;
    for (i = p = 0, len2 = propArray.length; p < len2; i = ++p) {
      prop = propArray[i];
      val = _.trim(lineParts[i + 1]);
      if (!val) {
        continue;
      }
      newObj[prop] = val;
      valFound = true;
    }
    if (valFound) {
      retArray.push(newObj);
    }
  }
  return retArray;
};

exports.format = format;

exports.parse = parse;
