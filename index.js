// Generated by IcedCoffeeScript 108.0.11
var dateformat, format, numeral, parse, _;

dateformat = require('dateformat-nodep');

numeral = require('numeral');

_ = require('lodash');

format = function(inputObj, options) {
  var columnHeaders, columnLengthArray, formatstr, i, j, k, key, keys, l, len, lineAr, linestr, longDashes, longStringOfSpaces, n, newStrAr, numberformat, o, obj, partsMax, rlen, sp, spacePad, spacePadLen, str, tempAr, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref, _ref1, _s, _t;
  options = options || {};
  lineAr = [];
  if (inputObj && inputObj.length) {
    obj = inputObj[0];
    keys = _.keys(obj);
    len = keys.length;
    partsMax = 1;
    columnLengthArray = {};
    if (options.longdateformat) {
      formatstr = 'mm/dd/yyyy  hh:MM tt';
    } else {
      formatstr = 'mmm dd  hh:MM tt';
    }
    for (i = _i = 0, _len = keys.length; _i < _len; i = ++_i) {
      key = keys[i];
      columnLengthArray[key] = 3;
      sp = key.split(/[_\.]/);
      for (_j = 0, _len1 = sp.length; _j < _len1; _j++) {
        str = sp[_j];
        columnLengthArray[key] = Math.max(columnLengthArray[key], str.length);
      }
      partsMax = Math.max(partsMax, sp.length);
    }
    for (j = _k = 0, _len2 = inputObj.length; _k < _len2; j = ++_k) {
      obj = inputObj[j];
      for (k = _l = 0, _len3 = keys.length; _l < _len3; k = ++_l) {
        key = keys[k];
        val = obj[key];
        if (val) {
          if (_.isDate(val)) {
            val = dateformat(val, formatstr);
          } else if (_.isNumber(val)) {
            numberformat = options != null ? (_ref = options.numberformat) != null ? _ref[key] : void 0 : void 0;
            if (numberformat) {
              val = numeral(val).format(numberformat);
            }
          }
          columnLengthArray[key] = Math.max(val.toString().length, columnLengthArray[key]);
        }
      }
    }
    longStringOfSpaces = '                                                                                                                                                                                                                                                                                                ';
    longDashes = '------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------';
    linestr = '';
    newStrAr = [];
    for (i = _m = 0; _m < partsMax; i = _m += 1) {
      newStrAr.push('');
    }
    for (l = _n = 0, _len4 = keys.length; _n < _len4; l = ++_n) {
      key = keys[l];
      tempAr = [];
      for (i = _o = 0; _o < partsMax; i = _o += 1) {
        tempAr.push('');
      }
      sp = key.split(/[_\.]/);
      for (i = _p = 0, _len5 = sp.length; _p < _len5; i = ++_p) {
        str = sp[i];
        tempAr[i] = str;
      }
      while (!tempAr[partsMax - 1]) {
        tempAr.pop();
        tempAr.unshift('');
      }
      for (i = _q = 0, _len6 = tempAr.length; _q < _len6; i = ++_q) {
        str = tempAr[i];
        spacePadLen = columnLengthArray[key] + 1 - str.length;
        spacePad = longStringOfSpaces.slice(0, +spacePadLen + 1 || 9e9);
        newStrAr[i] += str + spacePad + " ";
      }
    }
    columnHeaders = newStrAr.join('\n');
    lineAr.push('');
    lineAr.push(columnHeaders);
    linestr = '';
    for (i = _r = 0, _len7 = keys.length; _r < _len7; i = ++_r) {
      key = keys[i];
      linestr += longDashes.slice(1, +columnLengthArray[key] + 1 || 9e9) + "   ";
    }
    lineAr.push(linestr);
    for (n = _s = 0, _len8 = inputObj.length; _s < _len8; n = ++_s) {
      obj = inputObj[n];
      linestr = '';
      for (o = _t = 0, _len9 = keys.length; _t < _len9; o = ++_t) {
        key = keys[o];
        val = obj[key];
        if (_.isArray(val)) {
          val = JSON.stringify(val);
        }
        if (_.isBoolean(val)) {
          val = val.toString();
        }
        if (_.isNumber(val)) {
          numberformat = options != null ? (_ref1 = options.numberformat) != null ? _ref1[key] : void 0 : void 0;
          if (numberformat) {
            val = numeral(val).format(numberformat);
          }
          val = _.trim(val.toString());
          len = val.length;
          spacePadLen = columnLengthArray[key] - len;
          spacePad = longStringOfSpaces.slice(1, +spacePadLen + 1 || 9e9);
          if (options.meetInMiddle) {
            if (spacePad.length > 60) {
              spacePad = spacePad.substring(0, 60);
            }
          }
          if (options.meetInMiddle && o % 2 === 1) {
            linestr += val + spacePad + "   ";
          } else {
            linestr += spacePad + val.toString() + "   ";
          }
        } else {
          if (toString.call(val) === '[object Date]') {
            val = dateformat(val, formatstr);
            val = val.replace(', 0', ',  ');
          }
          if (val == null) {
            val = '';
          }
          spacePadLen = columnLengthArray[key] + 1 - val.length;
          spacePad = longStringOfSpaces.slice(1, +spacePadLen + 1 || 9e9);
          if (options.meetInMiddle) {
            if (spacePad.length > 60) {
              spacePad = spacePad.substring(0, 60);
            }
          }
          if (options.meetInMiddle && o % 2 === 0) {
            spacePad = longStringOfSpaces.slice(2, +spacePadLen + 1 || 9e9);
            linestr += spacePad + val + "   ";
          } else {
            linestr += val + spacePad + "  ";
          }
        }
      }
      lineAr.push(linestr.substr(0, linestr.length - 2));
    }
    rlen = inputObj.length;
    if (rlen === 1) {
      lineAr.push("  (1 row returned)");
    } else {
      lineAr.push("  (" + rlen + " rows returned)");
    }
    lineAr.push('');
  } else {
    lineAr.push("  (0 rows returned)");
  }
  return lineAr.join('\n');
};

parse = function(text) {
  var headerSeen, i, line, lineParts, lines, newObj, prop, propArray, retArray, val, valFound, _i, _j, _len, _len1;
  retArray = [];
  headerSeen = false;
  propArray = [];
  lines = _.split(text, '\n');
  for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
    line = lines[i];
    line = _.trim(line);
    if (_.startsWith(line, '#')) {
      continue;
    }
    if (!line) {
      continue;
    }
    lineParts = _.split(line, '|');
    if (lineParts.length < 3) {
      continue;
    }
    if (_.startsWith(lineParts[1], '-')) {
      continue;
    }
    if (!headerSeen) {
      headerSeen = true;
      propArray = lineParts.slice(1).map(function(item) {
        return _.trim(item);
      }).filter(function(item) {
        return item !== '';
      });
      continue;
    }
    newObj = {};
    valFound = false;
    for (i = _j = 0, _len1 = propArray.length; _j < _len1; i = ++_j) {
      prop = propArray[i];
      val = _.trim(lineParts[i + 1]);
      if (!val) {
        continue;
      }
      newObj[prop] = val;
      valFound = true;
    }
    if (valFound) {
      retArray.push(newObj);
    }
  }
  return retArray;
};

exports.format = format;

exports.parse = parse;
