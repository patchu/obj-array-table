// Generated by CoffeeScript 2.3.1
var _, dateformat, format, numeral, parse;

dateformat = require('dateformat-nodep');

numeral = require('numeral');

_ = require('lodash');

// input is an array of rows
// [
//		{col1: val, col2: val2}
//		{col1: val, col2: val2}
//		{col1: val, col2: val2}
// ]
// columns are built based on the keys of the first object
// options:
//		longdateformat: true/false, print the year for date fields?
//		meetInMiddle: right-justify even columns and left-justify odd columns
format = function(inputObj, options) {
  var betweenStr, borderline, bottomline, collen, columnHeaders, columnLengthArray, diff, extra, formatstr, i, j, k, key, keys, l, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, lineAr, linestr, longDashes, longStringOfSpaces, m, n, newStrAr, numberformat, o, obj, p, partsMax, q, r, ref, ref1, ref2, ref3, rlen, s, sp, spacePad, spacePadLen, startLine, str, t, tempAr, topline, u, v, val, w, x, y, z;
  options = options || {};
  betweenStr = "│";
  startLine = "│";
  if (options.spaceDivider) {
    betweenStr = " ";
    startLine = " ";
  }
  lineAr = [];
  if (inputObj && inputObj.length) {
    obj = inputObj[0];
    keys = _.keys(obj);
    len = keys.length;
    partsMax = 1; // a "part" is a column name divided by "."
    
    // find the longest length of each column
    columnLengthArray = {};
    if (options.longdateformat) {
      formatstr = 'mm/dd/yyyy  hh:MM tt';
    } else {
      formatstr = 'mmm dd  hh:MM tt';
    }
// seed the value with the column name
    for (i = m = 0, len1 = keys.length; m < len1; i = ++m) {
      key = keys[i];
      columnLengthArray[key] = 3;
      sp = key.split(/[_\.]/);
      for (p = 0, len2 = sp.length; p < len2; p++) {
        str = sp[p];
        // set to the longest of the split parts
        columnLengthArray[key] = Math.max(columnLengthArray[key], str.length);
      }
      partsMax = Math.max(partsMax, sp.length);
    }
// j index
// now cycle through each row and get the longest string
    for (j = q = 0, len3 = inputObj.length; q < len3; j = ++q) {
      obj = inputObj[j];
// k index
      for (k = r = 0, len4 = keys.length; r < len4; k = ++r) {
        key = keys[k];
        val = obj[key];
        if (val) {
          if (_.isDate(val)) {
            val = dateformat(val, formatstr);
          } else if (_.isNumber(val)) {
            numberformat = options != null ? (ref = options.numberformat) != null ? ref[key] : void 0 : void 0;
            if (numberformat) {
              val = numeral(val).format(numberformat);
            }
          }
          columnLengthArray[key] = Math.max(val.toString().length, columnLengthArray[key]);
        }
      }
    }
    // console.log partsMax, columnLengthArray
    longStringOfSpaces = '                                                                                                                                                                                                                                                                                                ';
    longDashes = '────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────';
    // print the column names
    // dotted columns names will be displayed in multiple lines
    linestr = startLine;
    newStrAr = [];
    for (i = s = 0, ref1 = partsMax; s < ref1; i = s += 1) {
      newStrAr.push(startLine);
    }
    borderline = startLine;
// l
    for (l = t = 0, len5 = keys.length; t < len5; l = ++t) {
      key = keys[l];
      collen = columnLengthArray[key];
      // configure border line (top and bottom) first
      borderline += longDashes.slice(0, collen + 2) + betweenStr;
      tempAr = [];
      for (i = u = 0, ref2 = partsMax; u < ref2; i = u += 1) {
        tempAr.push('');
      }
      sp = key.split(/[_\.]/);
      for (i = v = 0, len6 = sp.length; v < len6; i = ++v) {
        str = sp[i];
        tempAr[i] = str;
      }
      // console.log ''
      // console.log 'start tempAr: ', tempAr

      // pop away blank lines, push everything down
      while (!tempAr[partsMax - 1]) {
        tempAr.pop();
        tempAr.unshift('');
      }
// console.log 'end tempAr: ', tempAr
      for (i = w = 0, len7 = tempAr.length; w < len7; i = ++w) {
        str = tempAr[i];
        // for blank strings, just output collen + 2
        if (!str.length) {
          newStrAr[i] += ' ' + longStringOfSpaces.slice(0, collen) + ' ' + betweenStr;
          continue;
        }
        spacePad = '';
        extra = '';
        if (collen !== str.length) {
          // padding needed
          diff = collen - str.length;
          spacePad = longStringOfSpaces.slice(0, (diff / 2));
          extra = longStringOfSpaces.slice(0, (diff % 2));
        }
        newStrAr[i] += ' ' + spacePad + str + extra + spacePad + ' ' + betweenStr;
      }
    }
    // console.log newStrAr

    // next two statement: total hacks
    // eliminate blank lines
    // while not trim newStrAr[newStrAr.length-1]
    // 	newStrAr.splice newStrAr.length-1,1

    // while not trim newStrAr[0]
    // 	newStrAr.splice 0,1
    columnHeaders = newStrAr.join('\n');
    // console.log columnHeaders, newStrAr

    // lineAr.push linestr
    lineAr.push(columnHeaders);
    // print the dashes under the column names
    linestr = '├─';
    for (i = x = 0, len8 = keys.length; x < len8; i = ++x) {
      key = keys[i];
      linestr += `${longDashes.slice(1, +columnLengthArray[key] + 1 || 9e9)}─${betweenStr}─`;
    }
    if (options.spaceDivider) {
      linestr = linestr.replace(/─\ ─/g, '─┼─');
      linestr = linestr.replace(/┼─$/g, '┤');
    } else {
      linestr = linestr.replace(/─│─/g, '─┼─');
      linestr = linestr.replace(/┼─$/g, '┤');
    }
    lineAr.push(linestr);
// n index
// now cycle again and print result
    for (n = y = 0, len9 = inputObj.length; y < len9; n = ++y) {
      obj = inputObj[n];
      linestr = startLine + ' ';
// o index
      for (o = z = 0, len10 = keys.length; z < len10; o = ++z) {
        key = keys[o];
        val = obj[key];
        if (_.isArray(val)) {
          val = JSON.stringify(val);
        }
        if (_.isBoolean(val)) {
          val = val.toString();
        }
        if (_.isNumber(val)) {
          numberformat = options != null ? (ref3 = options.numberformat) != null ? ref3[key] : void 0 : void 0;
          if (numberformat) {
            val = numeral(val).format(numberformat);
          }
          val = _.trim(val.toString());
          len = val.length;
          // lineAr.push 'length, value, stored len: ', len, val, columnLengthArray[key]
          spacePadLen = columnLengthArray[key] - len;
          // lineAr.push 'spacePadLen: ', spacePadLen
          spacePad = longStringOfSpaces.slice(1, +spacePadLen + 1 || 9e9);
          // linestr += spacePad+val.toString()+" | "
          if (options.meetInMiddle) {
            if (spacePad.length > 60) {
              spacePad = spacePad.substring(0, 60);
            }
          }
          if (options.meetInMiddle && o % 2 === 1) {
            // linestr += val+spacePad+"   "
            linestr += `${val}${spacePad} ${betweenStr} `;
          } else {
            linestr += `${spacePad}${val.toString()} ${betweenStr} `;
          }
        } else {
          if (toString.call(val) === '[object Date]') {
            val = dateformat(val, formatstr);
            val = val.replace(', 0', ',  ');
          }
          if (val == null) {
            val = '';
          }
          spacePadLen = columnLengthArray[key] + 1 - val.length;
          spacePad = longStringOfSpaces.slice(1, +spacePadLen + 1 || 9e9);
          // linestr += val+spacePad+"| "
          if (options.meetInMiddle) {
            if (spacePad.length > 60) {
              spacePad = spacePad.substring(0, 60);
            }
          }
          if (options.meetInMiddle && o % 2 === 0) {
            spacePad = longStringOfSpaces.slice(2, +spacePadLen + 1 || 9e9);
            // linestr += spacePad+val+betweenStr
            linestr += `${spacePad}${val}${betweenStr} `;
          } else {
            // linestr += val+spacePad+betweenStr
            linestr += `${val}${spacePad}${betweenStr} `;
          }
        }
      }
      linestr += betweenStr;
      // output the right bar to tne the string

      // final transformations

      // leave out the trailing |
      linestr = linestr.substr(0, linestr.length - 2);
      lineAr.push(linestr);
    }
    // add border lines
    if (options.spaceDivider) {
      topline = borderline.replace(/─\ ─/g, '─┬─');
      topline = topline.replace(/\ ─/g, '┌─');
      topline = topline.replace(/─\ /g, '─┐');
      bottomline = borderline.replace(/─\ ─/g, '─┴─');
      bottomline = bottomline.replace(/\ ─/g, '└─');
      bottomline = bottomline.replace(/─\ /g, '─┘');
    } else {
      topline = borderline.replace(/─│─/g, '─┬─');
      topline = topline.replace(/│─/g, '┌─');
      topline = topline.replace(/─│/g, '─┐');
      bottomline = borderline.replace(/─│─/g, '─┴─');
      bottomline = bottomline.replace(/│─/g, '└─');
      bottomline = bottomline.replace(/─│/g, '─┘');
    }
    lineAr.unshift(topline);
    lineAr.unshift('');
    lineAr.push(bottomline);
    rlen = inputObj.length;
    if (rlen === 1) {
      lineAr.push("  (1 row returned)");
    } else {
      lineAr.push(`  (${rlen} rows returned)`);
    }
    lineAr.push('');
  } else {
    lineAr.push("  (0 rows returned)");
  }
  return lineAr.join('\n');
};

// given a string in table format, returns an array of objects
// uses the first line as properties for objects
parse = function(text) {
  var headerSeen, i, len1, len2, line, lineParts, lines, m, newObj, p, prop, propArray, retArray, val, valFound;
  retArray = [];
  headerSeen = false;
  propArray = [];
  lines = _.split(text, '\n');
  for (i = m = 0, len1 = lines.length; m < len1; i = ++m) {
    line = lines[i];
    line = _.trim(line);
    if (_.startsWith(line, '#')) {
      // if line starts with a comment, ignore it
      continue;
    }
    if (!line) {
      continue;
    }
    lineParts = _.split(line, '|');
    if (lineParts.length < 3) {
      // vertical bar not found
      continue;
    }
    if (_.startsWith(lineParts[1], '-')) {
      continue;
    }
    if (!headerSeen) {
      headerSeen = true;
      propArray = lineParts.slice(1).map(function(item) {
        return _.trim(item);
      }).filter(function(item) {
        return item !== '';
      });
      continue;
    }
    newObj = {};
    valFound = false;
    for (i = p = 0, len2 = propArray.length; p < len2; i = ++p) {
      prop = propArray[i];
      val = _.trim(lineParts[i + 1]);
      if (!val) {
        continue;
      }
      newObj[prop] = val;
      valFound = true;
    }
    if (valFound) {
      retArray.push(newObj);
    }
  }
  return retArray;
};

exports.format = format;

exports.parse = parse;
